<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS专精-JSON格式/JSON对象/深拷贝/函数作为参数</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="">
    <link rel="preload" href="/study_blog/assets/css/0.styles.26012ee8.css" as="style"><link rel="preload" href="/study_blog/assets/js/app.fa73ec29.js" as="script"><link rel="preload" href="/study_blog/assets/js/2.c359b067.js" as="script"><link rel="preload" href="/study_blog/assets/js/10.711088b9.js" as="script"><link rel="prefetch" href="/study_blog/assets/js/11.4bc7751b.js"><link rel="prefetch" href="/study_blog/assets/js/12.6bd1c5ed.js"><link rel="prefetch" href="/study_blog/assets/js/13.68deeced.js"><link rel="prefetch" href="/study_blog/assets/js/14.315144b3.js"><link rel="prefetch" href="/study_blog/assets/js/15.9342324c.js"><link rel="prefetch" href="/study_blog/assets/js/16.1310006a.js"><link rel="prefetch" href="/study_blog/assets/js/17.b94b283d.js"><link rel="prefetch" href="/study_blog/assets/js/18.f7bd3752.js"><link rel="prefetch" href="/study_blog/assets/js/19.4f83ae72.js"><link rel="prefetch" href="/study_blog/assets/js/20.10e28f9e.js"><link rel="prefetch" href="/study_blog/assets/js/21.133ed4c6.js"><link rel="prefetch" href="/study_blog/assets/js/22.ea3da500.js"><link rel="prefetch" href="/study_blog/assets/js/23.90f06376.js"><link rel="prefetch" href="/study_blog/assets/js/24.7e0e6769.js"><link rel="prefetch" href="/study_blog/assets/js/25.76892a53.js"><link rel="prefetch" href="/study_blog/assets/js/26.a0ff0e69.js"><link rel="prefetch" href="/study_blog/assets/js/27.0e7a093f.js"><link rel="prefetch" href="/study_blog/assets/js/28.9e443cbf.js"><link rel="prefetch" href="/study_blog/assets/js/29.3555568a.js"><link rel="prefetch" href="/study_blog/assets/js/3.03532752.js"><link rel="prefetch" href="/study_blog/assets/js/30.b7e07863.js"><link rel="prefetch" href="/study_blog/assets/js/31.ecec9c8f.js"><link rel="prefetch" href="/study_blog/assets/js/32.2ba959f9.js"><link rel="prefetch" href="/study_blog/assets/js/33.0c26e454.js"><link rel="prefetch" href="/study_blog/assets/js/34.22f8a3a3.js"><link rel="prefetch" href="/study_blog/assets/js/35.ba45dd05.js"><link rel="prefetch" href="/study_blog/assets/js/36.b92c80eb.js"><link rel="prefetch" href="/study_blog/assets/js/37.466f0839.js"><link rel="prefetch" href="/study_blog/assets/js/38.ed111741.js"><link rel="prefetch" href="/study_blog/assets/js/39.02b875d0.js"><link rel="prefetch" href="/study_blog/assets/js/4.b5d9f4e7.js"><link rel="prefetch" href="/study_blog/assets/js/40.b5a19844.js"><link rel="prefetch" href="/study_blog/assets/js/5.c2d54515.js"><link rel="prefetch" href="/study_blog/assets/js/6.413eb2f7.js"><link rel="prefetch" href="/study_blog/assets/js/7.546e37c0.js"><link rel="prefetch" href="/study_blog/assets/js/8.7aba858b.js"><link rel="prefetch" href="/study_blog/assets/js/9.9023b09e.js">
    <link rel="stylesheet" href="/study_blog/assets/css/0.styles.26012ee8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/study_blog/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/study_blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="/study_blog/ambition/2020/" class="nav-link">
  日记
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/study_blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="/study_blog/ambition/2020/" class="nav-link">
  日记
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/study_blog/" class="sidebar-link">Home</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JS语言特性</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study_blog/ES6/hoisting/" class="sidebar-link">JS专精-变量提升/函数</a></li><li><a href="/study_blog/ES6/lexicalenvironment/" class="sidebar-link">JS专精-执行上下文/函数</a></li><li><a href="/study_blog/ES6/closure/" class="sidebar-link">JS 专精-函数/闭包</a></li><li><a href="/study_blog/ES6/fibonacc/" class="sidebar-link">JS专精-递归/尾递归/记忆化/react的记忆化</a></li><li><a href="/study_blog/ES6/currying/" class="sidebar-link">JS专精-柯里化/闭包隐藏变量的原因</a></li><li><a href="/study_blog/ES6/eventhub/" class="sidebar-link">JS专精-EventHub/ts实现</a></li><li><a href="/study_blog/ES6/deepclone/" class="active sidebar-link">JS专精-JSON格式/JSON对象/深拷贝/函数作为参数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#序列化和反序列化" class="sidebar-link">序列化和反序列化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#json格式" class="sidebar-link">JSON格式</a></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#交互" class="sidebar-link">交互</a></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#json-对值的类型和格式有严格的规定" class="sidebar-link">JSON 对值的类型和格式有严格的规定</a></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#数组和对象" class="sidebar-link">数组和对象</a></li></ul></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#json-对象" class="sidebar-link">JSON 对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#json-stringify" class="sidebar-link">JSON.stringify</a></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#错误" class="sidebar-link">错误</a></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#json-parse" class="sidebar-link">JSON.parse()</a></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#错误-2" class="sidebar-link">错误</a></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#总结" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#递归克隆" class="sidebar-link">递归克隆</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#instanceof运算符" class="sidebar-link">instanceof运算符</a></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#函数的深拷贝" class="sidebar-link">函数的深拷贝</a></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#深拷贝" class="sidebar-link">深拷贝</a></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#环的深拷贝" class="sidebar-link">环的深拷贝</a></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#日期和正则" class="sidebar-link">日期和正则</a></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#for-in" class="sidebar-link">for in</a></li><li class="sidebar-sub-header"><a href="/study_blog/ES6/deepclone/#面向对象" class="sidebar-link">面向对象</a></li></ul></li></ul></li><li><a href="/study_blog/ES6/bind/" class="sidebar-link">JS专精-实现bind/apply/call</a></li><li><a href="/study_blog/ES6/promise/" class="sidebar-link">手写 Promise</a></li><li><a href="/study_blog/ES6/promise2/" class="sidebar-link">手写 Promise-重置版</a></li><li><a href="/study_blog/ES6/eventloop/" class="sidebar-link">浏览器的事件循环</a></li><li><a href="/study_blog/ES6/await/" class="sidebar-link">async</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>网页API</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React开发</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue开发</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS生态</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>刷题</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js专精-json格式-json对象-深拷贝-函数作为参数"><a href="#js专精-json格式-json对象-深拷贝-函数作为参数" class="header-anchor">#</a> JS专精-JSON格式/JSON对象/深拷贝/函数作为参数</h1> <p>深拷贝:拷贝前后的两个对象之间没有任何互相引用</p> <h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="header-anchor">#</a> 序列化和反序列化</h2> <h3 id="json格式"><a href="#json格式" class="header-anchor">#</a> JSON格式</h3> <ul><li>JSON：JavaScript Object Notation 【JavaScript 对象表示法】</li> <li>JSON不是编程语言是标记语言，跟HTML、XML、Markdown 一样，用来展示数据不涉及编译就普普通通放在内存中。</li> <li>JSON是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON采用完全独立于语言的文本格式， 这些特性使JSON成为理想的数据交换语言。</li></ul> <h3 id="交互"><a href="#交互" class="header-anchor">#</a> 交互</h3> <p>客户端与服务端的交互数据无非就是两种，数组，对象。对象是一个无序的“‘名称/值’对”集合。数组是值（value）的有序集合。</p> <h3 id="json-对值的类型和格式有严格的规定"><a href="#json-对值的类型和格式有严格的规定" class="header-anchor">#</a> JSON 对值的类型和格式有严格的规定</h3> <ul><li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li> <li>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。</li> <li>字符串必须使用双引号表示，不能使用单引号。</li> <li>对象的键名必须放在双引号里面。</li> <li>数组或对象最后一个成员的后面，不能加逗号。</li></ul> <h3 id="数组和对象"><a href="#数组和对象" class="header-anchor">#</a> 数组和对象</h3> <p><img src="https://user-gold-cdn.xitu.io/2020/5/21/17237327348aebe8?w=1280&amp;h=588&amp;f=png&amp;s=160493" alt=""></p> <p><img src="https://user-gold-cdn.xitu.io/2020/5/21/1723733137b9fba9?w=1280&amp;h=346&amp;f=png&amp;s=93462" alt=""></p> <ul><li>值（value）可以是双引号括起来的字符串（string）、数值(number)、true、false、 null、对象（object）或者数组（array）。这些结构可以嵌套。</li></ul> <h2 id="json-对象"><a href="#json-对象" class="header-anchor">#</a> JSON 对象</h2> <p>JSON对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：JSON.stringify()和JSON.parse()</p> <h3 id="json-stringify"><a href="#json-stringify" class="header-anchor">#</a> JSON.stringify</h3> <p>JSON.stringify方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。</p> <div class="language- extra-class"><pre class="language-text"><code>JSON.stringify('abc') // &quot;&quot;abc&quot;&quot;
JSON.stringify(1) // &quot;1&quot;
JSON.stringify(false) // &quot;false&quot;
JSON.stringify([]) // &quot;[]&quot;
JSON.stringify({}) // &quot;{}&quot;

JSON.stringify([1, &quot;false&quot;, false])
// '[1,&quot;false&quot;,false]'

JSON.stringify({ name: &quot;张三&quot; })
// '{&quot;name&quot;:&quot;张三&quot;}'
</code></pre></div><h3 id="错误"><a href="#错误" class="header-anchor">#</a> 错误</h3> <ul><li>如果对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify过滤忽略。</li> <li>如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。</li> <li>不可以环引用会出错</li> <li>不支持new Date() 会转换成ISO8601字符串</li> <li>不支持正则表达式会变成空对象</li></ul> <h3 id="json-parse"><a href="#json-parse" class="header-anchor">#</a> JSON.parse()</h3> <p>JSON.parse方法用于将 JSON 字符串转换成对应的值。</p> <div class="language- extra-class"><pre class="language-text"><code>JSON.parse('{}') // {}
JSON.parse('true') // true
JSON.parse('&quot;foo&quot;') // &quot;foo&quot;
JSON.parse('[1, 5, &quot;false&quot;]') // [1, 5, &quot;false&quot;]
JSON.parse('null') // null

var o = JSON.parse('{&quot;name&quot;: &quot;张三&quot;}');
o.name // 张三
</code></pre></div><h3 id="错误-2"><a href="#错误-2" class="header-anchor">#</a> 错误</h3> <p>如果发生错误，json语法不符合规则，就会出错，或者</p> <div class="language- extra-class"><pre class="language-text"><code>try {
  JSON.parse(&quot;'String'&quot;);
} catch(e) {
  console.log('parsing error');
}
</code></pre></div><p>try catch js代码来消化错误</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <ul><li>json格式和json对象不一样，一个是数据格式，一个是js库，<strong>json格式都是字符串</strong></li> <li>我们拿到json字符串，再变成js对象</li> <li>json是xml的升级版，比xml可以更好的体现出数据结构</li></ul> <h2 id="递归克隆"><a href="#递归克隆" class="header-anchor">#</a> 递归克隆</h2> <p>JS的七种数据类型，除了object之外赋值只是简单的赋值而已，object赋值的地址，date，regExp，set，map都是对象的子类型</p> <h3 id="instanceof运算符"><a href="#instanceof运算符" class="header-anchor">#</a> instanceof运算符</h3> <p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。[]instanceof Object 是正确的。Object的prototype属性出现在了[]实例原型链上</p> <h3 id="函数的深拷贝"><a href="#函数的深拷贝" class="header-anchor">#</a> 函数的深拷贝</h3> <div class="language- extra-class"><pre class="language-text"><code>function deepClone(source) {
//////
if (source instanceof Function) {
      const dist = function() {
        return source.bind(this)(...arguments);
      };
      return dist;
  }
////
}
</code></pre></div><p>上面很好理解：我们调用dist时source.bind(this)会返回一个新的函数，bind中的this是dist调用时决定的，重新调用dist会重新绑定this，之后我们再修改source并不会影响source.bind(this)返回的新函数，自然不会影响dist</p> <div class="language- extra-class"><pre class="language-text"><code>function deepClone(source) {
//////
if (source instanceof Function) {
      const dist = function() {
        return source.apply(this,arguments);
      };
      return dist;
  }
////
}
</code></pre></div><p>再看看上面代码你可能会有一个错觉我们修改source会影响dist函数。其实不会下面我们分析一下：</p> <div class="language- extra-class"><pre class="language-text"><code>let a = function(a, b) {
  return a + b;
};
let b = deepClone(a);
</code></pre></div><ol><li>我们把a代表的函数地址（#101）传入deepClone</li> <li>deepClone接受到函数（#101），dist使用apply调用函数（#101）</li> <li>我们修改a = function(a,b){a+2*b}</li> <li>此时<strong>变量</strong>a代表的函数地址改变（#102），但是 deepClone的参数仍是（#101）</li> <li>函数深拷贝其实很容易因为你无法在不创建新函数的情况下去修改一个原来的函数，函数作为参数一但传进去只要外部的函数（deepClone）不重新调用就不会改变</li></ol> <h3 id="深拷贝"><a href="#深拷贝" class="header-anchor">#</a> 深拷贝</h3> <div class="language- extra-class"><pre class="language-text"><code>function deepClone(source) {
  if (source instanceof Object) {
    if (source instanceof Array) {
      const dist = [];
      for (let key in source) {
        dist[key] = deepClone(source[key]);
      }
      return dist;
    } else if (source instanceof Function) {
      const dist = function() {
        console.log(source === a);
        return source.bind(this)(...arguments);
      };
      return dist;
    } else {
      const dist = {};
      for (let key in source) {
        dist[key] = deepClone(source[key]);
      }
      return dist;
    }
  } else return source;
}
</code></pre></div><h3 id="环的深拷贝"><a href="#环的深拷贝" class="header-anchor">#</a> 环的深拷贝</h3> <p>采用缓存[source, dist]存到数组中，根据source找dist即可</p> <div class="language- extra-class"><pre class="language-text"><code>let cache = [];
function findCache(source) {
  for (let i = 0; i &lt; cache.length; i++) {
    if (cache[i][0] === source) {
      return cache[i][1];
    }
  }
  return undefined;
}
function deepClone(source) {
  if (source instanceof Object) {
    let cacheDist = findCache(source);
    if (cacheDist) {
      return cacheDist;
    } else {
      let dist;
      if (source instanceof Array) {} 
      else if (source instanceof Function) {} 
      else {
        dist = {};
        cache.push([source, dist]);
        for (let key in source) {
          if (source.hasOwnProperty(key)) {
            dist[key] = deepClone(source[key]);
          }
        }
      }
      return dist;
    }
  } else return source;
}
</code></pre></div><h3 id="日期和正则"><a href="#日期和正则" class="header-anchor">#</a> 日期和正则</h3> <div class="language- extra-class"><pre class="language-text"><code>    if (source instanceof RegExp) {
        dist = new RegExp(source.source, source.flags);
      } else if (source instanceof Date) {
        dist = new Date(source);
    } 
</code></pre></div><h3 id="for-in"><a href="#for-in" class="header-anchor">#</a> for in</h3> <p>for...in 循环只遍历可枚举属性（包括它的原型链上的可枚举属性）。需要hasOwnProperty进行筛选</p> <h3 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h3> <div class="language- extra-class"><pre class="language-text"><code>class Clone {
  cache = [];
  deepClone(source) {}
  findCache(source) {}
}
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/study_blog/ES6/eventhub/" class="prev">
        JS专精-EventHub/ts实现
      </a></span> <span class="next"><a href="/study_blog/ES6/bind/">
        JS专精-实现bind/apply/call
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/study_blog/assets/js/app.fa73ec29.js" defer></script><script src="/study_blog/assets/js/2.c359b067.js" defer></script><script src="/study_blog/assets/js/10.711088b9.js" defer></script>
  </body>
</html>
