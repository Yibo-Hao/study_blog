(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{390:function(n,a,t){"use strict";t.r(a);var e=t(43),s=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"js专精-递归-尾递归-记忆化-react的记忆化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js专精-递归-尾递归-记忆化-react的记忆化"}},[n._v("#")]),n._v(" JS专精-递归/尾递归/记忆化/react的记忆化")]),n._v(" "),t("h2",{attrs:{id:"递归实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#递归实现"}},[n._v("#")]),n._v(" 递归实现")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function fibonacc(n) {\n  if (n === 0) {\n    n = 0;\n  } else if (n === 1) {\n    n =  1;\n  } else {\n    n =  fibonacc(n - 1) + fibonacc(n - 2);\n  }\n  return n\n}\n")])])]),t("h2",{attrs:{id:"调用栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调用栈"}},[n._v("#")]),n._v(" 调用栈")]),n._v(" "),t("ul",[t("li",[n._v("JS引擎解析出全局上下文和可执行代码")]),n._v(" "),t("li",[n._v("然后把全局上下文压入栈，执行可执行代码遇到函数调用")]),n._v(" "),t("li",[n._v("把函数解析成同样两部分，把函数上下文压入栈")]),n._v(" "),t("li",[n._v("执行完之后弹栈更新全局上下文")]),n._v(" "),t("li",[n._v("递归就是不停地压栈，压到顶之后开始弹并且更新上一级上下文。")]),n._v(" "),t("li",[n._v("注意只压上下文")])]),n._v(" "),t("h2",{attrs:{id:"优化递归-尾递归"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化递归-尾递归"}},[n._v("#")]),n._v(" 优化递归-尾递归")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function fibonacc2(n) {\n  return fibonacc3(2, n, 1, 0);\n}\nfunction fibonacc3(start, end, prev1, prev2) {\n  if (start === end) {\n    start = prev1 + prev2;\n  } else {\n    fibonacc3(start + 1, end, prev1 + prev2, prev2);\n  }\n}\n")])])]),t("p",[n._v("注意单纯地把递归放到函数末尾并不是尾递归看下面代码：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function fibonacc(n) {\n  if (n === 0) {\n    return 0;\n  } else if (n === 1) {\n    return  1;\n  } else {\n    return  fibonacc(n - 1) + fibonacc(n - 2);\n  }\n}\n")])])]),t("p",[n._v("fibonacc(n-1)结束后仍需要它的返回值来进行相加，所以必须保存fibonacc(n)的环境以供处理返回值。")]),n._v(" "),t("ul",[t("li",[t("strong",[n._v("尾递归：进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。")])]),n._v(" "),t("li",[t("strong",[n._v("非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。")])]),n._v(" "),t("li",[n._v("尾递归通常会多一个参数，这个参数是上一次调用函数得到的结果，尾递归每次调用都在收集结果")])]),n._v(" "),t("p",[n._v("但是JS就算下一个函数不再需要上一个函数的环境，仍然会压栈，所以JS没有尾递归操作。")]),n._v(" "),t("h2",{attrs:{id:"循环代替递归"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#循环代替递归"}},[n._v("#")]),n._v(" 循环代替递归")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function fibonacc4(n) {\n  let fibArray = [0, 1];\n  for (let i = 0; i <= n - 2; i++) {\n    fibArray[i + 2] = fibArray[i + 1] + fibArray[i];\n  }\n  return fibArray[fibArray.length - 1];\n}\n")])])]),t("h2",{attrs:{id:"记忆化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#记忆化"}},[n._v("#")]),n._v(" 记忆化")]),n._v(" "),t("p",[n._v("虽然上一段代码是用数组实现的，也把算下来的值记录下来了，但这不是记忆化，比如说一次n是5另一次是4,第二次仍需要完整地计算一遍")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function memozi(fn) {\n  const cache = {};\n  return function(n) {\n    if (cache[n] == null) {\n      cache[n] = fn(n);\n      return cache[n];\n    } else {\n      return cache[n];\n    }\n  };\n}\n\nconst fibfn = memozi(function (n) {\n  if (n === 0) {\n    return 0;\n  } else if (n === 1) {\n    return 1;\n  } else {\n    return fibfn(n - 1) + fibfn(n - 2);\n  }\n});\n")])])]),t("ul",[t("li",[n._v("使用一个哈希表完整地记录下来所有的计算结果")]),n._v(" "),t("li",[n._v("计算第n个，就要去记忆里去找fibfn(n - 1) + fibfn(n - 2)")]),n._v(" "),t("li",[n._v("我们使用memozi返回的函数即可，如果这个函数在记忆查找无果那么就会调用memozi的回调函数来进行计算")]),n._v(" "),t("li",[n._v("记忆化：当memozi里面的回调没有变化时，就会从记忆中寻找值")]),n._v(" "),t("li",[n._v("记忆化同样是使用闭包完成的，memozi的作用就是创建并隐藏一个cache，返回一个函数fn，每次调用fn并不会重新创建cache只是修改cache，但是每次重新调用memozi会重新创建cache")])]),n._v(" "),t("h2",{attrs:{id:"raect记忆化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raect记忆化"}},[n._v("#")]),n._v(" Raect记忆化")]),n._v(" "),t("p",[n._v("上面记忆化代码是否很像React的memo钩子。")]),n._v(" "),t("p",[n._v("React每次数据改变父组件函数会重新执行，而里面的子组件函数也会重新运行。虽然DOM没有更新但是子组件里面的代码会重新执行（得出的DOM仍和上次一样所以没有更新页面）。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("child2 = React.memo(child)\n")])])]),t("p",[n._v("但是")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("<child2 onClick = {()=>{}}/>\n")])])]),t("p",[n._v("即使已经记忆化，点击child2时child2仍会重新执行，因为onClick的函数每次点击时就会创建新的函数，child2认为不一样了就会重新执行")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let x = ()=>{}\n<child2 onClick = {x}/>\n")])])]),t("p",[n._v("这样仍会重新执行child2，因为父组件会重新执行，每次都会重新声明x。")]),n._v(" "),t("p",[n._v("我们需要函数的记忆化：我们们使用n来作为记忆索引，只要n不变那么这个函数就不变")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let x = React.useCallback(()=>{},[n])\n")])])]),t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[n._v("#")]),n._v(" 小结")]),n._v(" "),t("ul",[t("li",[n._v("fibonacc的记忆化依靠n（第几个数）来索引")]),n._v(" "),t("li",[n._v("React索引依靠我们提供数据来索引")])])])}),[],!1,null,null,null);a.default=s.exports}}]);