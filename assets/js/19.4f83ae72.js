(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{372:function(s,t,e){"use strict";e.r(t);var a=e(43),r=Object(a.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"react的css方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react的css方案"}},[s._v("#")]),s._v(" React的CSS方案")]),s._v(" "),e("h2",{attrs:{id:"css的缺陷"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css的缺陷"}},[s._v("#")]),s._v(" CSS的缺陷")]),s._v(" "),e("ul",[e("li",[s._v("样式与状态相关的情况越来越多，需要动态、能直接访问组件state的css。")]),s._v(" "),e("li",[s._v("css不是组件化。一切样式都是全局，类的命名重复，但当你使用三方插件时却无法避免命名冲突。")]),s._v(" "),e("li")]),s._v(" "),e("h2",{attrs:{id:"关于sass题外话"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于sass题外话"}},[s._v("#")]),s._v(" 关于sass题外话")]),s._v(" "),e("ul",[e("li",[s._v("sass指预编译器和缩进式css语言")]),s._v(" "),e("li",[s._v("预编译器有两种node-sass和dart-sass，node-sass已经退出舞台了")]),s._v(" "),e("li",[s._v("scss并不能解决css的问题")])]),s._v(" "),e("h2",{attrs:{id:"vue的解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue的解决方案"}},[s._v("#")]),s._v(" Vue的解决方案")]),s._v(" "),e("ul",[e("li",[s._v("v-bind 和 class/style 的结合,解决了依赖变化时样式发生变化"),e("br"),s._v(" "),e("code",[s._v('<div v-bind:class="{ active: isActive }"></div>')]),s._v("，"),e("br"),s._v(" "),e("code",[s._v('<div v-bind:class="[activeClass, errorClass]"></div>')]),s._v("，"),e("br"),s._v(" "),e("code",[s._v('<div v-bind:style="styleObject"></div>')]),e("br"),s._v(" "),e("code",[s._v('<div v-bind:style="[baseStyles, overridingStyles]"></div>')])]),s._v(" "),e("li",[s._v("scoped css的语法")])]),s._v(" "),e("h2",{attrs:{id:"内联css"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内联css"}},[s._v("#")]),s._v(" 内联CSS")]),s._v(" "),e("p",[s._v("传统的inline-style")]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("const textStyles = {\n  color: 'white',\n  backgroundColor: this.state.bgColor\n};\n\n<p style={textStyles}>inline style</p>\n")])])]),e("p",[s._v("和Vue的内联样式非常相似")]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("<div v-bind:style=\"styleObject\"></div>\ndata: {\n  styleObject: {\n    color: 'red',\n    fontSize: '13px'\n  }\n}\n")])])]),e("p",[s._v("缺陷：")]),s._v(" "),e("ul",[e("li",[s._v("内联样式并不支持所有的 css，媒体查询，:before和:nth-child等 pseudo selectors")])]),s._v(" "),e("p",[s._v("Vue可以通过计算属性计算出一个样式对象，解决了样式与状态相关的情况。切换class也可以做到")]),s._v(" "),e("h2",{attrs:{id:"引入式css"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引入式css"}},[s._v("#")]),s._v(" 引入式CSS")]),s._v(" "),e("p",[s._v("最普通常见的方式，在 jsx 文件中引入"),e("code",[s._v("import './App.css'")]),s._v("，这种方式适合引入CSS-reset和SCSS的全局变量。")]),s._v(" "),e("p",[s._v("@import-normalize 是 create-react-app 官方自带的 reset 和我们常用的 reset 的区别就在于，我们会把所有样式都清零，而normalize只是给所有标签加了一个默认样式，消除了不同浏览器对不同标签的默认样式。")]),s._v(" "),e("p",[s._v("normalize 并没有什么卵用。")]),s._v(" "),e("h2",{attrs:{id:"css-in-js"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css-in-js"}},[s._v("#")]),s._v(" Css in Js")]),s._v(" "),e("p",[s._v("主要依赖于很多React库Radium，Aphrodite，下面介绍一下"),e("a",{attrs:{href:"https://github.com/FormidableLabs/radium/tree/master/docs/guides",target:"_blank",rel:"noopener noreferrer"}},[s._v("Radium"),e("OutboundLink")],1)]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("import Radium from 'radium';\n\nconst Button = () => (\n    <button\n        style={styles.red}>\n        {this.props.children}\n    </button>;\n)\n\nvar styles = {\n  red: {\n    backgroundColor: 'red'\n  }\n};\n\nButton = Radium(Button);\n")])])]),e("p",[s._v("Radium is activated by wrapping your component。")]),s._v(" "),e("p",[s._v("这种类型的库扩展了React能支持的css的范围，并且通过给Button组件传入一个对象，并把对象放到style数组中，完成了根据state变化style")]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("    style={[\n      styles.base,\n      this.props.block && styles.block\n    ]}>\n")])])]),e("p",[s._v("样式只作用于import它的组件")]),s._v(" "),e("h2",{attrs:{id:"css-modules"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css-modules"}},[s._v("#")]),s._v(" Css Modules")]),s._v(" "),e("p",[s._v("Css Modules 并不是React专用解决方法，适用于所有使用 webpack 等打包工具的开发环境。以 webpack 为例，在 css-loader 的 options 里打开modules：true 选项即可")]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("import styles from './table.css';\n\n    render () {\n        return <div className={styles.table}>\n            <div className={styles.row}>\n                <div className={styles.cell}>A0</div>\n                <div className={styles.cell}>B0</div>\n            </div>\n        </div>;\n    }\n/* table.css */\n.table {}\n.row {}\n.cell {}\n")])])]),e("p",[s._v("Css Modules还有一大缺憾：和Vue的解决一样，因为css写在css文件，无法处理动态css。")]),s._v(" "),e("h2",{attrs:{id:"styled-components"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#styled-components"}},[s._v("#")]),s._v(" styled-components")]),s._v(" "),e("p",[s._v("ES6 的模板字符串，在js文件里写纯粹的css。")]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("const Title = styled.h1`\n  font-size: 1.5em;\n  text-align: center;\n  color: palevioletred;\n`;\n")])])]),e("p",[s._v("返回的是一个带样式的组件")]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("// 在充分使用css全部功能的同时，非常方便的实现动态css， 甚至可以直接调用props！\nconst Wrapper = styled.section`\n  padding: 4em;\n  background: ${props => props.bgColor};\n`;\n")])])]),e("h2",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),e("ul",[e("li",[s._v("要解决的两个问题：模块化和动态css")]),s._v(" "),e("li",[s._v("内联CSS，引入式CSS，CSS in JS，Css Modules")]),s._v(" "),e("li",[s._v("内联CSS：部分伪元素选择器不支持")]),s._v(" "),e("li",[s._v("引入式：样式作用于全局")]),s._v(" "),e("li",[s._v("CSS in JS：很好的实现了state和style的结合，因为css就在js文件里直接访问就行")]),s._v(" "),e("li",[s._v("CSS in JS 是对内联CSS的升级补充了内联不支持的部分选择器，完美地实现了模块化和动态CSS")]),s._v(" "),e("li",[s._v("Css Modules:利用className来处理样式，无法处理动态css。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);