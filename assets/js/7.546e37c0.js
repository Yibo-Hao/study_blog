(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{365:function(n,t,e){"use strict";e.r(t);var a=e(43),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"js专精-实现bind-apply-call"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js专精-实现bind-apply-call"}},[n._v("#")]),n._v(" JS专精-实现bind/apply/call")]),n._v(" "),e("h2",{attrs:{id:"实现bind代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现bind代码"}},[n._v("#")]),n._v(" 实现bind代码")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("export default function myBind(context, ...args) {\n  const fn = this;\n  args = args ? args : [];\n  return function(...newFnArgs) {\n    return fn.call(context, ...args, ...newFnArgs);\n  };\n}\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let bind = Function.prototype.bind;\nbind.call(f1,this,arguments)\n")])])]),e("ul",[e("li",[n._v("函数也是可以调用函数的，比如f1.bind()，自然bind的this就是函数")]),n._v(" "),e("li",[n._v("bind是返回一个绑定好的函数")]),n._v(" "),e("li",[n._v("参数一但传进来变成函数词法环境静态的一部分，不会改变的，所以达到了绑定的效果")])]),n._v(" "),e("h2",{attrs:{id:"支持-new-的-bind"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#支持-new-的-bind"}},[n._v("#")]),n._v(" 支持 new 的 bind")]),n._v(" "),e("p",[n._v("要让bind返回的函数支持new操作，new操作会做下面四件事")]),n._v(" "),e("ol",[e("li",[n._v("创建空对象obj")]),n._v(" "),e("li",[e("code",[n._v("obj.__proto__ = F1.prototype")])]),n._v(" "),e("li",[n._v("F1.call(obj)")]),n._v(" "),e("li",[n._v("return obj")])]),n._v(" "),e("p",[n._v("注意事项：")]),n._v(" "),e("ul",[e("li",[n._v("如果构造函数自带return，那么new的return obj不会实现")]),n._v(" "),e("li",[n._v("对于 new 来说， bind 绑定的 this 不影响构造函数里的 this。")]),n._v(" "),e("li",[e("code",[n._v("let f1 = F1.bind(undefined,xxx)")])])]),n._v(" "),e("p",[n._v("我们现在要让 f1 支持 new：")]),n._v(" "),e("ul",[e("li",[e("code",[n._v("new f1")]),n._v(" 由于源代码是返回一个函数调用导致new的时候无法返回实例对象，所以我们要判断当f1函数（bind返回的函数）前加new时，要返回一个实例。")]),n._v(" "),e("li",[n._v("我们根据new的四个过程发现f1.call(obj)和"),e("code",[n._v("obj.__proto__ = F1.prototype")]),n._v(" 所以添加判断this instanceof newFn")]),n._v(" "),e("li",[n._v("但是我们想要的是fn的原型而不是newFn的原型")]),n._v(" "),e("li",[n._v("我们new的其实是newFn但是返回的却是new fn，根据new newFn来判断this instanceof newFn，判断成功返回new fn，new newFn只是缺少了四步new过程的最后一步而已。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Function.prototype.myBind = function (context, ...args) {\n    const fn = this\n    args = args ? args : []\n    return function newFn(...newFnArgs) {\n        if (this instanceof newFn) {\n            return new fn(...args, ...newFnArgs)\n        }\n        return fn.apply(context, [...args,...newFnArgs])\n    }\n}\n")])])]),e("h2",{attrs:{id:"实现call"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现call"}},[n._v("#")]),n._v(" 实现call")]),n._v(" "),e("p",[n._v("this拿到f.call的f函数，context.this来调用函数")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("    function myCall(context, ...args) {\n    context = context || window\n    args = args ? args : []\n    const key = Symbol()\n    context[key] = this\n    const result = context[key](...args)\n    delete context[key]\n    return result\n}\n")])])]),e("h2",{attrs:{id:"实现apply"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现apply"}},[n._v("#")]),n._v(" 实现apply")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("    myApply = function myApply (context, args) {\n    context = context || window\n    args = args ? args : []\n    const key = Symbol()\n    context[key] = this\n    const result = context[key](...args)\n    delete context[key]\n    return result\n}\n")])])]),e("p",[n._v("因为context是别人传过来的")]),n._v(" "),e("h2",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[n._v("#")]),n._v(" 小结")]),n._v(" "),e("ul",[e("li",[n._v("call实现总结：this只有在调用时才知道，所以使用this拿到f，用context调用f即可===>context[key] = f")]),n._v(" "),e("li",[n._v("bind实现技术总结：利用参数传进来的this不会改变，利用call调用即可")])])])}),[],!1,null,null,null);t.default=s.exports}}]);